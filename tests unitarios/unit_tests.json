{
  "stats": {
    "suites": 11,
    "tests": 10,
    "passes": 8,
    "pending": 0,
    "failures": 2,
    "start": "2021-12-07T15:28:12.370Z",
    "end": "2021-12-07T15:28:12.396Z",
    "duration": 26,
    "testsRegistered": 10,
    "passPercent": 80,
    "pendingPercent": 0,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false
  },
  "results": [
    {
      "uuid": "016016e9-0ceb-4f52-94a9-28c6b4665396",
      "title": "",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "48f81c61-cd9c-4403-9436-d707be123397",
          "title": "TFG Skill",
          "fullFile": "C:\\Users\\juanp\\Desktop\\Skill TFG\\lambda\\test.js",
          "file": "\\test.js",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "c10d6250-fd5c-4c43-a8f6-9be07af7ed22",
              "title": "LaunchRequest",
              "fullFile": "C:\\Users\\juanp\\Desktop\\Skill TFG\\lambda\\test.js",
              "file": "\\test.js",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "returns the correct responses",
                  "fullTitle": "TFG Skill LaunchRequest returns the correct responses",
                  "timedOut": false,
                  "duration": 5,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "var run = function (handler, sequenceIndex, attributes) {\n\tif (sequenceIndex >= sequence.length) {\n\t\t// all requests were executed\n\t\tdone();\n\t}\n\telse {\n\t\tvar ctx = awsContext(self.mockContextOptions);\n\t\tvar currentItem = sequence[sequenceIndex];\n\t\t\n\t\tvar request = currentItem.request;\n\t\trequest.session.new = sequenceIndex === 0;\n\t\tif (attributes) {\n\t\t\trequest.session.attributes = JSON.parse(JSON.stringify(attributes));\n\t\t} else {\n\t\t\trequest.session.attributes = {};\n\t\t}\n\t\trequest.session.sessionId = randomSessionId;\n\t\tvar callback = function (err, result) {\n\t\t\tif (err) {\n\t\t\t\treturn ctx.fail(err);\n\t\t\t}\n\t\t\treturn ctx.succeed(result);\n\t\t};\n\t\t// adds values from withSessionAttributes to the session\n\t\tif (currentItem.withSessionAttributes) {\n\t\t\tvar session = request.session.attributes;\n\t\t\tfor (var newAttribute in currentItem.withSessionAttributes) {\n\t\t\t\tif (!session[newAttribute]) {\n\t\t\t\t\tsession[newAttribute] = currentItem.withSessionAttributes[newAttribute];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar requestType = request.request.type;\n\t\tif (requestType === \"IntentRequest\") {\n\t\t\trequestType = request.request.intent.name;\n\t\t}\n\t\tvar context = new CallbackContext(self, sequenceIndex, locale, requestType);\n\t\t\n\t\tif (self.dynamoDBTable) {\n\t\t\tself.dynamoDBGetMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Key[self.partitionKeyName], self.userId);\n\t\t\t\t\n\t\t\t\tconst Item = {};\n\t\t\t\tItem[self.partitionKeyName] = self.userId;\n\t\t\t\tItem[self.attributesName] = currentItem.withStoredAttributes || {};\n\t\t\t\tcallback(null, {TableName: self.dynamoDBTable, Item});\n\t\t\t};\n\t\t\tself.dynamoDBPutMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Item[self.partitionKeyName], self.userId);\n\t\t\t\tlet storesAttributes = currentItem.storesAttributes;\n\t\t\t\tif (storesAttributes) {\n\t\t\t\t\tfor (let att in storesAttributes) {\n\t\t\t\t\t\tif (storesAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tconst storedAttr = params.Item[self.attributesName][att];\n\t\t\t\t\t\t\tif (typeof storesAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!storesAttributes[att](storedAttr)) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the stored attribute \" + att + \" did not contain the correct value. Value was: \" + storedAttr});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, storedAttr, storesAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback(null, {});\n\t\t\t};\n\t\t}\n\t\t\n\t\tvar result = handler(request, ctx, callback, true);\n\t\tif (result) {\n\t\t\tif (result.then) {\n\t\t\t\tresult.then(ctx.succeed, ctx.fail);\n\t\t\t} else {\n\t\t\t\tctx.succeed(result);\n\t\t\t}\n\t\t}\n\t\t\n\t\tctx.Promise\n\t\t\t.then(response => {\n\t\t\t\t//TODO: null checks\n\t\t\t\t\n\t\t\t\tif (response.toJSON) {\n\t\t\t\t\tresponse = response.toJSON();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar actualSay = response.response && response.response.outputSpeech ? response.response.outputSpeech.ssml : undefined;\n\t\t\t\tvar actualReprompt = response.response && response.response.reprompt && response.response.reprompt.outputSpeech ? response.response.reprompt.outputSpeech.ssml : undefined;\n\t\t\t\t\n\t\t\t\t// check the returned speech\n\t\t\t\tif (currentItem.says !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'speech', actualSay);\n\t\t\t\t\tvar trimActualSay = actualSay.substring(7);\n\t\t\t\t\ttrimActualSay = trimActualSay.substring(0, trimActualSay.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.says)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"speech\", actualSay, currentItem.saysLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"speech\", actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.reprompts !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'reprompt', actualReprompt);\n\t\t\t\t\tvar trimActualReprompt = actualReprompt.substring(7);\n\t\t\t\t\ttrimActualReprompt = trimActualReprompt.substring(0, trimActualReprompt.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.reprompts)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"reprompt\", actualReprompt, currentItem.repromptsLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"reprompt\", actualReprompt);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.elicitsSlot) {\n\t\t\t\t\tlet elicitSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ElicitSlot');\n\t\t\t\t\tlet slot = elicitSlotDirective ? elicitSlotDirective.slotToElicit : '';\n\t\t\t\t\tself._assertStringEqual(context, \"elicitSlot\", slot, currentItem.elicitsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsSlot) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmSlot');\n\t\t\t\t\tlet slot = confirmSlotDirective ? confirmSlotDirective.slotToConfirm : '';\n\t\t\t\t\tself._assertStringEqual(context, \"confirmSlot\", slot, currentItem.confirmsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsIntent) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmIntent');\n\t\t\t\t\tif (!confirmSlotDirective) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not ask Alexa to confirm the intent\"});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasAttributes) {\n\t\t\t\t\tfor (let att in currentItem.hasAttributes) {\n\t\t\t\t\t\tif (currentItem.hasAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tif (typeof currentItem.hasAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!currentItem.hasAttributes[att](response.sessionAttributes[att])) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the attribute \" + att + \" did not contain the correct value. Value was: \" + response.sessionAttributes[att]});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, response.sessionAttributes[att], currentItem.hasAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardTitle) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardTitle\", response.response.card.title, currentItem.hasCardTitle);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardContent) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardContent\", response.response.card.content, currentItem.hasCardContent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardContentLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardContent\", response.response.card.content, currentItem.hasCardContentLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardText) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardText\", response.response.card.text, currentItem.hasCardText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardTextLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardText\", response.response.card.text, currentItem.hasCardTextLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasSmallImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"smallImageUrl\", response.response.card.image.smallImageUrl, currentItem.hasSmallImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasLargeImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"largeImageUrl\", response.response.card.image.largeImageUrl, currentItem.hasLargeImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// check the shouldEndSession flag\n\t\t\t\tif (currentItem.shouldEndSession === true && response.response.shouldEndSession === false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response did not end the session\",\n\t\t\t\t\t\t\texpected: \"the response ends the session\",\n\t\t\t\t\t\t\tactual: \"the response did not end the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if (currentItem.shouldEndSession === false && response.response.shouldEndSession !== false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response ended the session\",\n\t\t\t\t\t\t\texpected: \"the response does not end the session\",\n\t\t\t\t\t\t\tactual: \"the response ended the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcheckAudioPlayer(self, context, response, currentItem);\n\t\t\t\t\n\t\t\t\t// custom checks\n\t\t\t\tif (currentItem.saysCallback) {\n\t\t\t\t\tcurrentItem.saysCallback(context, actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.callback) {\n\t\t\t\t\tcurrentItem.callback(context, response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// extra checks\n\t\t\t\tif (self.extraFeatures.questionMarkCheck) {\n\t\t\t\t\tcontext._questionMarkCheck(response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trun(handler, sequenceIndex + 1, response.sessionAttributes);\n\t\t\t})\n\t\t\t.catch(done);\n\t}\n};\nrun(index.handler, 0, {});",
                  "err": {},
                  "uuid": "8b4c6e5a-5014-446d-8ce6-d8ae318fc36e",
                  "parentUUID": "c10d6250-fd5c-4c43-a8f6-9be07af7ed22",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "8b4c6e5a-5014-446d-8ce6-d8ae318fc36e"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 5,
              "root": false,
              "rootEmpty": false,
              "_timeout": 2000
            },
            {
              "uuid": "8b3bf521-52bf-4fb8-a9bc-cf0170de487f",
              "title": "RegisterNameIntent",
              "fullFile": "C:\\Users\\juanp\\Desktop\\Skill TFG\\lambda\\test.js",
              "file": "\\test.js",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "returns the correct responses",
                  "fullTitle": "TFG Skill RegisterNameIntent returns the correct responses",
                  "timedOut": false,
                  "duration": 0,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "var run = function (handler, sequenceIndex, attributes) {\n\tif (sequenceIndex >= sequence.length) {\n\t\t// all requests were executed\n\t\tdone();\n\t}\n\telse {\n\t\tvar ctx = awsContext(self.mockContextOptions);\n\t\tvar currentItem = sequence[sequenceIndex];\n\t\t\n\t\tvar request = currentItem.request;\n\t\trequest.session.new = sequenceIndex === 0;\n\t\tif (attributes) {\n\t\t\trequest.session.attributes = JSON.parse(JSON.stringify(attributes));\n\t\t} else {\n\t\t\trequest.session.attributes = {};\n\t\t}\n\t\trequest.session.sessionId = randomSessionId;\n\t\tvar callback = function (err, result) {\n\t\t\tif (err) {\n\t\t\t\treturn ctx.fail(err);\n\t\t\t}\n\t\t\treturn ctx.succeed(result);\n\t\t};\n\t\t// adds values from withSessionAttributes to the session\n\t\tif (currentItem.withSessionAttributes) {\n\t\t\tvar session = request.session.attributes;\n\t\t\tfor (var newAttribute in currentItem.withSessionAttributes) {\n\t\t\t\tif (!session[newAttribute]) {\n\t\t\t\t\tsession[newAttribute] = currentItem.withSessionAttributes[newAttribute];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar requestType = request.request.type;\n\t\tif (requestType === \"IntentRequest\") {\n\t\t\trequestType = request.request.intent.name;\n\t\t}\n\t\tvar context = new CallbackContext(self, sequenceIndex, locale, requestType);\n\t\t\n\t\tif (self.dynamoDBTable) {\n\t\t\tself.dynamoDBGetMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Key[self.partitionKeyName], self.userId);\n\t\t\t\t\n\t\t\t\tconst Item = {};\n\t\t\t\tItem[self.partitionKeyName] = self.userId;\n\t\t\t\tItem[self.attributesName] = currentItem.withStoredAttributes || {};\n\t\t\t\tcallback(null, {TableName: self.dynamoDBTable, Item});\n\t\t\t};\n\t\t\tself.dynamoDBPutMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Item[self.partitionKeyName], self.userId);\n\t\t\t\tlet storesAttributes = currentItem.storesAttributes;\n\t\t\t\tif (storesAttributes) {\n\t\t\t\t\tfor (let att in storesAttributes) {\n\t\t\t\t\t\tif (storesAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tconst storedAttr = params.Item[self.attributesName][att];\n\t\t\t\t\t\t\tif (typeof storesAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!storesAttributes[att](storedAttr)) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the stored attribute \" + att + \" did not contain the correct value. Value was: \" + storedAttr});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, storedAttr, storesAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback(null, {});\n\t\t\t};\n\t\t}\n\t\t\n\t\tvar result = handler(request, ctx, callback, true);\n\t\tif (result) {\n\t\t\tif (result.then) {\n\t\t\t\tresult.then(ctx.succeed, ctx.fail);\n\t\t\t} else {\n\t\t\t\tctx.succeed(result);\n\t\t\t}\n\t\t}\n\t\t\n\t\tctx.Promise\n\t\t\t.then(response => {\n\t\t\t\t//TODO: null checks\n\t\t\t\t\n\t\t\t\tif (response.toJSON) {\n\t\t\t\t\tresponse = response.toJSON();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar actualSay = response.response && response.response.outputSpeech ? response.response.outputSpeech.ssml : undefined;\n\t\t\t\tvar actualReprompt = response.response && response.response.reprompt && response.response.reprompt.outputSpeech ? response.response.reprompt.outputSpeech.ssml : undefined;\n\t\t\t\t\n\t\t\t\t// check the returned speech\n\t\t\t\tif (currentItem.says !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'speech', actualSay);\n\t\t\t\t\tvar trimActualSay = actualSay.substring(7);\n\t\t\t\t\ttrimActualSay = trimActualSay.substring(0, trimActualSay.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.says)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"speech\", actualSay, currentItem.saysLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"speech\", actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.reprompts !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'reprompt', actualReprompt);\n\t\t\t\t\tvar trimActualReprompt = actualReprompt.substring(7);\n\t\t\t\t\ttrimActualReprompt = trimActualReprompt.substring(0, trimActualReprompt.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.reprompts)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"reprompt\", actualReprompt, currentItem.repromptsLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"reprompt\", actualReprompt);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.elicitsSlot) {\n\t\t\t\t\tlet elicitSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ElicitSlot');\n\t\t\t\t\tlet slot = elicitSlotDirective ? elicitSlotDirective.slotToElicit : '';\n\t\t\t\t\tself._assertStringEqual(context, \"elicitSlot\", slot, currentItem.elicitsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsSlot) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmSlot');\n\t\t\t\t\tlet slot = confirmSlotDirective ? confirmSlotDirective.slotToConfirm : '';\n\t\t\t\t\tself._assertStringEqual(context, \"confirmSlot\", slot, currentItem.confirmsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsIntent) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmIntent');\n\t\t\t\t\tif (!confirmSlotDirective) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not ask Alexa to confirm the intent\"});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasAttributes) {\n\t\t\t\t\tfor (let att in currentItem.hasAttributes) {\n\t\t\t\t\t\tif (currentItem.hasAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tif (typeof currentItem.hasAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!currentItem.hasAttributes[att](response.sessionAttributes[att])) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the attribute \" + att + \" did not contain the correct value. Value was: \" + response.sessionAttributes[att]});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, response.sessionAttributes[att], currentItem.hasAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardTitle) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardTitle\", response.response.card.title, currentItem.hasCardTitle);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardContent) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardContent\", response.response.card.content, currentItem.hasCardContent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardContentLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardContent\", response.response.card.content, currentItem.hasCardContentLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardText) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardText\", response.response.card.text, currentItem.hasCardText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardTextLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardText\", response.response.card.text, currentItem.hasCardTextLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasSmallImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"smallImageUrl\", response.response.card.image.smallImageUrl, currentItem.hasSmallImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasLargeImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"largeImageUrl\", response.response.card.image.largeImageUrl, currentItem.hasLargeImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// check the shouldEndSession flag\n\t\t\t\tif (currentItem.shouldEndSession === true && response.response.shouldEndSession === false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response did not end the session\",\n\t\t\t\t\t\t\texpected: \"the response ends the session\",\n\t\t\t\t\t\t\tactual: \"the response did not end the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if (currentItem.shouldEndSession === false && response.response.shouldEndSession !== false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response ended the session\",\n\t\t\t\t\t\t\texpected: \"the response does not end the session\",\n\t\t\t\t\t\t\tactual: \"the response ended the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcheckAudioPlayer(self, context, response, currentItem);\n\t\t\t\t\n\t\t\t\t// custom checks\n\t\t\t\tif (currentItem.saysCallback) {\n\t\t\t\t\tcurrentItem.saysCallback(context, actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.callback) {\n\t\t\t\t\tcurrentItem.callback(context, response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// extra checks\n\t\t\t\tif (self.extraFeatures.questionMarkCheck) {\n\t\t\t\t\tcontext._questionMarkCheck(response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trun(handler, sequenceIndex + 1, response.sessionAttributes);\n\t\t\t})\n\t\t\t.catch(done);\n\t}\n};\nrun(index.handler, 0, {});",
                  "err": {},
                  "uuid": "bb7da91a-9554-4088-8bc4-cc98e96f1e3b",
                  "parentUUID": "8b3bf521-52bf-4fb8-a9bc-cf0170de487f",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "bb7da91a-9554-4088-8bc4-cc98e96f1e3b"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 2000
            },
            {
              "uuid": "c62241f4-d2b1-492a-a67c-1d3462925907",
              "title": "RegisterAgeIntent",
              "fullFile": "C:\\Users\\juanp\\Desktop\\Skill TFG\\lambda\\test.js",
              "file": "\\test.js",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "returns the correct responses",
                  "fullTitle": "TFG Skill RegisterAgeIntent returns the correct responses",
                  "timedOut": false,
                  "duration": 0,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "var run = function (handler, sequenceIndex, attributes) {\n\tif (sequenceIndex >= sequence.length) {\n\t\t// all requests were executed\n\t\tdone();\n\t}\n\telse {\n\t\tvar ctx = awsContext(self.mockContextOptions);\n\t\tvar currentItem = sequence[sequenceIndex];\n\t\t\n\t\tvar request = currentItem.request;\n\t\trequest.session.new = sequenceIndex === 0;\n\t\tif (attributes) {\n\t\t\trequest.session.attributes = JSON.parse(JSON.stringify(attributes));\n\t\t} else {\n\t\t\trequest.session.attributes = {};\n\t\t}\n\t\trequest.session.sessionId = randomSessionId;\n\t\tvar callback = function (err, result) {\n\t\t\tif (err) {\n\t\t\t\treturn ctx.fail(err);\n\t\t\t}\n\t\t\treturn ctx.succeed(result);\n\t\t};\n\t\t// adds values from withSessionAttributes to the session\n\t\tif (currentItem.withSessionAttributes) {\n\t\t\tvar session = request.session.attributes;\n\t\t\tfor (var newAttribute in currentItem.withSessionAttributes) {\n\t\t\t\tif (!session[newAttribute]) {\n\t\t\t\t\tsession[newAttribute] = currentItem.withSessionAttributes[newAttribute];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar requestType = request.request.type;\n\t\tif (requestType === \"IntentRequest\") {\n\t\t\trequestType = request.request.intent.name;\n\t\t}\n\t\tvar context = new CallbackContext(self, sequenceIndex, locale, requestType);\n\t\t\n\t\tif (self.dynamoDBTable) {\n\t\t\tself.dynamoDBGetMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Key[self.partitionKeyName], self.userId);\n\t\t\t\t\n\t\t\t\tconst Item = {};\n\t\t\t\tItem[self.partitionKeyName] = self.userId;\n\t\t\t\tItem[self.attributesName] = currentItem.withStoredAttributes || {};\n\t\t\t\tcallback(null, {TableName: self.dynamoDBTable, Item});\n\t\t\t};\n\t\t\tself.dynamoDBPutMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Item[self.partitionKeyName], self.userId);\n\t\t\t\tlet storesAttributes = currentItem.storesAttributes;\n\t\t\t\tif (storesAttributes) {\n\t\t\t\t\tfor (let att in storesAttributes) {\n\t\t\t\t\t\tif (storesAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tconst storedAttr = params.Item[self.attributesName][att];\n\t\t\t\t\t\t\tif (typeof storesAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!storesAttributes[att](storedAttr)) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the stored attribute \" + att + \" did not contain the correct value. Value was: \" + storedAttr});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, storedAttr, storesAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback(null, {});\n\t\t\t};\n\t\t}\n\t\t\n\t\tvar result = handler(request, ctx, callback, true);\n\t\tif (result) {\n\t\t\tif (result.then) {\n\t\t\t\tresult.then(ctx.succeed, ctx.fail);\n\t\t\t} else {\n\t\t\t\tctx.succeed(result);\n\t\t\t}\n\t\t}\n\t\t\n\t\tctx.Promise\n\t\t\t.then(response => {\n\t\t\t\t//TODO: null checks\n\t\t\t\t\n\t\t\t\tif (response.toJSON) {\n\t\t\t\t\tresponse = response.toJSON();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar actualSay = response.response && response.response.outputSpeech ? response.response.outputSpeech.ssml : undefined;\n\t\t\t\tvar actualReprompt = response.response && response.response.reprompt && response.response.reprompt.outputSpeech ? response.response.reprompt.outputSpeech.ssml : undefined;\n\t\t\t\t\n\t\t\t\t// check the returned speech\n\t\t\t\tif (currentItem.says !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'speech', actualSay);\n\t\t\t\t\tvar trimActualSay = actualSay.substring(7);\n\t\t\t\t\ttrimActualSay = trimActualSay.substring(0, trimActualSay.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.says)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"speech\", actualSay, currentItem.saysLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"speech\", actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.reprompts !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'reprompt', actualReprompt);\n\t\t\t\t\tvar trimActualReprompt = actualReprompt.substring(7);\n\t\t\t\t\ttrimActualReprompt = trimActualReprompt.substring(0, trimActualReprompt.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.reprompts)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"reprompt\", actualReprompt, currentItem.repromptsLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"reprompt\", actualReprompt);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.elicitsSlot) {\n\t\t\t\t\tlet elicitSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ElicitSlot');\n\t\t\t\t\tlet slot = elicitSlotDirective ? elicitSlotDirective.slotToElicit : '';\n\t\t\t\t\tself._assertStringEqual(context, \"elicitSlot\", slot, currentItem.elicitsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsSlot) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmSlot');\n\t\t\t\t\tlet slot = confirmSlotDirective ? confirmSlotDirective.slotToConfirm : '';\n\t\t\t\t\tself._assertStringEqual(context, \"confirmSlot\", slot, currentItem.confirmsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsIntent) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmIntent');\n\t\t\t\t\tif (!confirmSlotDirective) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not ask Alexa to confirm the intent\"});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasAttributes) {\n\t\t\t\t\tfor (let att in currentItem.hasAttributes) {\n\t\t\t\t\t\tif (currentItem.hasAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tif (typeof currentItem.hasAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!currentItem.hasAttributes[att](response.sessionAttributes[att])) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the attribute \" + att + \" did not contain the correct value. Value was: \" + response.sessionAttributes[att]});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, response.sessionAttributes[att], currentItem.hasAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardTitle) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardTitle\", response.response.card.title, currentItem.hasCardTitle);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardContent) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardContent\", response.response.card.content, currentItem.hasCardContent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardContentLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardContent\", response.response.card.content, currentItem.hasCardContentLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardText) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardText\", response.response.card.text, currentItem.hasCardText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardTextLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardText\", response.response.card.text, currentItem.hasCardTextLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasSmallImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"smallImageUrl\", response.response.card.image.smallImageUrl, currentItem.hasSmallImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasLargeImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"largeImageUrl\", response.response.card.image.largeImageUrl, currentItem.hasLargeImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// check the shouldEndSession flag\n\t\t\t\tif (currentItem.shouldEndSession === true && response.response.shouldEndSession === false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response did not end the session\",\n\t\t\t\t\t\t\texpected: \"the response ends the session\",\n\t\t\t\t\t\t\tactual: \"the response did not end the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if (currentItem.shouldEndSession === false && response.response.shouldEndSession !== false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response ended the session\",\n\t\t\t\t\t\t\texpected: \"the response does not end the session\",\n\t\t\t\t\t\t\tactual: \"the response ended the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcheckAudioPlayer(self, context, response, currentItem);\n\t\t\t\t\n\t\t\t\t// custom checks\n\t\t\t\tif (currentItem.saysCallback) {\n\t\t\t\t\tcurrentItem.saysCallback(context, actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.callback) {\n\t\t\t\t\tcurrentItem.callback(context, response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// extra checks\n\t\t\t\tif (self.extraFeatures.questionMarkCheck) {\n\t\t\t\t\tcontext._questionMarkCheck(response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trun(handler, sequenceIndex + 1, response.sessionAttributes);\n\t\t\t})\n\t\t\t.catch(done);\n\t}\n};\nrun(index.handler, 0, {});",
                  "err": {},
                  "uuid": "e855ae7a-e4be-4c58-93c8-7f21f0edd9cd",
                  "parentUUID": "c62241f4-d2b1-492a-a67c-1d3462925907",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "e855ae7a-e4be-4c58-93c8-7f21f0edd9cd"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 2000
            },
            {
              "uuid": "3a8211a4-eb8d-4fb6-81a8-5478fee9c91e",
              "title": "CloseQuestionIntent",
              "fullFile": "C:\\Users\\juanp\\Desktop\\Skill TFG\\lambda\\test.js",
              "file": "\\test.js",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "returns the correct responses",
                  "fullTitle": "TFG Skill CloseQuestionIntent returns the correct responses",
                  "timedOut": false,
                  "duration": 0,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "var run = function (handler, sequenceIndex, attributes) {\n\tif (sequenceIndex >= sequence.length) {\n\t\t// all requests were executed\n\t\tdone();\n\t}\n\telse {\n\t\tvar ctx = awsContext(self.mockContextOptions);\n\t\tvar currentItem = sequence[sequenceIndex];\n\t\t\n\t\tvar request = currentItem.request;\n\t\trequest.session.new = sequenceIndex === 0;\n\t\tif (attributes) {\n\t\t\trequest.session.attributes = JSON.parse(JSON.stringify(attributes));\n\t\t} else {\n\t\t\trequest.session.attributes = {};\n\t\t}\n\t\trequest.session.sessionId = randomSessionId;\n\t\tvar callback = function (err, result) {\n\t\t\tif (err) {\n\t\t\t\treturn ctx.fail(err);\n\t\t\t}\n\t\t\treturn ctx.succeed(result);\n\t\t};\n\t\t// adds values from withSessionAttributes to the session\n\t\tif (currentItem.withSessionAttributes) {\n\t\t\tvar session = request.session.attributes;\n\t\t\tfor (var newAttribute in currentItem.withSessionAttributes) {\n\t\t\t\tif (!session[newAttribute]) {\n\t\t\t\t\tsession[newAttribute] = currentItem.withSessionAttributes[newAttribute];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar requestType = request.request.type;\n\t\tif (requestType === \"IntentRequest\") {\n\t\t\trequestType = request.request.intent.name;\n\t\t}\n\t\tvar context = new CallbackContext(self, sequenceIndex, locale, requestType);\n\t\t\n\t\tif (self.dynamoDBTable) {\n\t\t\tself.dynamoDBGetMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Key[self.partitionKeyName], self.userId);\n\t\t\t\t\n\t\t\t\tconst Item = {};\n\t\t\t\tItem[self.partitionKeyName] = self.userId;\n\t\t\t\tItem[self.attributesName] = currentItem.withStoredAttributes || {};\n\t\t\t\tcallback(null, {TableName: self.dynamoDBTable, Item});\n\t\t\t};\n\t\t\tself.dynamoDBPutMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Item[self.partitionKeyName], self.userId);\n\t\t\t\tlet storesAttributes = currentItem.storesAttributes;\n\t\t\t\tif (storesAttributes) {\n\t\t\t\t\tfor (let att in storesAttributes) {\n\t\t\t\t\t\tif (storesAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tconst storedAttr = params.Item[self.attributesName][att];\n\t\t\t\t\t\t\tif (typeof storesAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!storesAttributes[att](storedAttr)) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the stored attribute \" + att + \" did not contain the correct value. Value was: \" + storedAttr});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, storedAttr, storesAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback(null, {});\n\t\t\t};\n\t\t}\n\t\t\n\t\tvar result = handler(request, ctx, callback, true);\n\t\tif (result) {\n\t\t\tif (result.then) {\n\t\t\t\tresult.then(ctx.succeed, ctx.fail);\n\t\t\t} else {\n\t\t\t\tctx.succeed(result);\n\t\t\t}\n\t\t}\n\t\t\n\t\tctx.Promise\n\t\t\t.then(response => {\n\t\t\t\t//TODO: null checks\n\t\t\t\t\n\t\t\t\tif (response.toJSON) {\n\t\t\t\t\tresponse = response.toJSON();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar actualSay = response.response && response.response.outputSpeech ? response.response.outputSpeech.ssml : undefined;\n\t\t\t\tvar actualReprompt = response.response && response.response.reprompt && response.response.reprompt.outputSpeech ? response.response.reprompt.outputSpeech.ssml : undefined;\n\t\t\t\t\n\t\t\t\t// check the returned speech\n\t\t\t\tif (currentItem.says !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'speech', actualSay);\n\t\t\t\t\tvar trimActualSay = actualSay.substring(7);\n\t\t\t\t\ttrimActualSay = trimActualSay.substring(0, trimActualSay.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.says)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"speech\", actualSay, currentItem.saysLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"speech\", actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.reprompts !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'reprompt', actualReprompt);\n\t\t\t\t\tvar trimActualReprompt = actualReprompt.substring(7);\n\t\t\t\t\ttrimActualReprompt = trimActualReprompt.substring(0, trimActualReprompt.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.reprompts)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"reprompt\", actualReprompt, currentItem.repromptsLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"reprompt\", actualReprompt);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.elicitsSlot) {\n\t\t\t\t\tlet elicitSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ElicitSlot');\n\t\t\t\t\tlet slot = elicitSlotDirective ? elicitSlotDirective.slotToElicit : '';\n\t\t\t\t\tself._assertStringEqual(context, \"elicitSlot\", slot, currentItem.elicitsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsSlot) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmSlot');\n\t\t\t\t\tlet slot = confirmSlotDirective ? confirmSlotDirective.slotToConfirm : '';\n\t\t\t\t\tself._assertStringEqual(context, \"confirmSlot\", slot, currentItem.confirmsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsIntent) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmIntent');\n\t\t\t\t\tif (!confirmSlotDirective) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not ask Alexa to confirm the intent\"});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasAttributes) {\n\t\t\t\t\tfor (let att in currentItem.hasAttributes) {\n\t\t\t\t\t\tif (currentItem.hasAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tif (typeof currentItem.hasAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!currentItem.hasAttributes[att](response.sessionAttributes[att])) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the attribute \" + att + \" did not contain the correct value. Value was: \" + response.sessionAttributes[att]});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, response.sessionAttributes[att], currentItem.hasAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardTitle) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardTitle\", response.response.card.title, currentItem.hasCardTitle);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardContent) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardContent\", response.response.card.content, currentItem.hasCardContent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardContentLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardContent\", response.response.card.content, currentItem.hasCardContentLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardText) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardText\", response.response.card.text, currentItem.hasCardText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardTextLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardText\", response.response.card.text, currentItem.hasCardTextLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasSmallImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"smallImageUrl\", response.response.card.image.smallImageUrl, currentItem.hasSmallImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasLargeImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"largeImageUrl\", response.response.card.image.largeImageUrl, currentItem.hasLargeImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// check the shouldEndSession flag\n\t\t\t\tif (currentItem.shouldEndSession === true && response.response.shouldEndSession === false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response did not end the session\",\n\t\t\t\t\t\t\texpected: \"the response ends the session\",\n\t\t\t\t\t\t\tactual: \"the response did not end the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if (currentItem.shouldEndSession === false && response.response.shouldEndSession !== false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response ended the session\",\n\t\t\t\t\t\t\texpected: \"the response does not end the session\",\n\t\t\t\t\t\t\tactual: \"the response ended the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcheckAudioPlayer(self, context, response, currentItem);\n\t\t\t\t\n\t\t\t\t// custom checks\n\t\t\t\tif (currentItem.saysCallback) {\n\t\t\t\t\tcurrentItem.saysCallback(context, actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.callback) {\n\t\t\t\t\tcurrentItem.callback(context, response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// extra checks\n\t\t\t\tif (self.extraFeatures.questionMarkCheck) {\n\t\t\t\t\tcontext._questionMarkCheck(response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trun(handler, sequenceIndex + 1, response.sessionAttributes);\n\t\t\t})\n\t\t\t.catch(done);\n\t}\n};\nrun(index.handler, 0, {});",
                  "err": {},
                  "uuid": "6a561fd2-fa23-4c6c-ac59-591a846c01f4",
                  "parentUUID": "3a8211a4-eb8d-4fb6-81a8-5478fee9c91e",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "6a561fd2-fa23-4c6c-ac59-591a846c01f4"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 2000
            },
            {
              "uuid": "371cf801-3d4c-43e1-9dab-15f81d8f3907",
              "title": "OpenQuestionIntent into AMAZON.StartOverIntent",
              "fullFile": "C:\\Users\\juanp\\Desktop\\Skill TFG\\lambda\\test.js",
              "file": "\\test.js",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "returns the correct responses",
                  "fullTitle": "TFG Skill OpenQuestionIntent into AMAZON.StartOverIntent returns the correct responses",
                  "timedOut": false,
                  "duration": 0,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "var run = function (handler, sequenceIndex, attributes) {\n\tif (sequenceIndex >= sequence.length) {\n\t\t// all requests were executed\n\t\tdone();\n\t}\n\telse {\n\t\tvar ctx = awsContext(self.mockContextOptions);\n\t\tvar currentItem = sequence[sequenceIndex];\n\t\t\n\t\tvar request = currentItem.request;\n\t\trequest.session.new = sequenceIndex === 0;\n\t\tif (attributes) {\n\t\t\trequest.session.attributes = JSON.parse(JSON.stringify(attributes));\n\t\t} else {\n\t\t\trequest.session.attributes = {};\n\t\t}\n\t\trequest.session.sessionId = randomSessionId;\n\t\tvar callback = function (err, result) {\n\t\t\tif (err) {\n\t\t\t\treturn ctx.fail(err);\n\t\t\t}\n\t\t\treturn ctx.succeed(result);\n\t\t};\n\t\t// adds values from withSessionAttributes to the session\n\t\tif (currentItem.withSessionAttributes) {\n\t\t\tvar session = request.session.attributes;\n\t\t\tfor (var newAttribute in currentItem.withSessionAttributes) {\n\t\t\t\tif (!session[newAttribute]) {\n\t\t\t\t\tsession[newAttribute] = currentItem.withSessionAttributes[newAttribute];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar requestType = request.request.type;\n\t\tif (requestType === \"IntentRequest\") {\n\t\t\trequestType = request.request.intent.name;\n\t\t}\n\t\tvar context = new CallbackContext(self, sequenceIndex, locale, requestType);\n\t\t\n\t\tif (self.dynamoDBTable) {\n\t\t\tself.dynamoDBGetMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Key[self.partitionKeyName], self.userId);\n\t\t\t\t\n\t\t\t\tconst Item = {};\n\t\t\t\tItem[self.partitionKeyName] = self.userId;\n\t\t\t\tItem[self.attributesName] = currentItem.withStoredAttributes || {};\n\t\t\t\tcallback(null, {TableName: self.dynamoDBTable, Item});\n\t\t\t};\n\t\t\tself.dynamoDBPutMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Item[self.partitionKeyName], self.userId);\n\t\t\t\tlet storesAttributes = currentItem.storesAttributes;\n\t\t\t\tif (storesAttributes) {\n\t\t\t\t\tfor (let att in storesAttributes) {\n\t\t\t\t\t\tif (storesAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tconst storedAttr = params.Item[self.attributesName][att];\n\t\t\t\t\t\t\tif (typeof storesAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!storesAttributes[att](storedAttr)) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the stored attribute \" + att + \" did not contain the correct value. Value was: \" + storedAttr});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, storedAttr, storesAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback(null, {});\n\t\t\t};\n\t\t}\n\t\t\n\t\tvar result = handler(request, ctx, callback, true);\n\t\tif (result) {\n\t\t\tif (result.then) {\n\t\t\t\tresult.then(ctx.succeed, ctx.fail);\n\t\t\t} else {\n\t\t\t\tctx.succeed(result);\n\t\t\t}\n\t\t}\n\t\t\n\t\tctx.Promise\n\t\t\t.then(response => {\n\t\t\t\t//TODO: null checks\n\t\t\t\t\n\t\t\t\tif (response.toJSON) {\n\t\t\t\t\tresponse = response.toJSON();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar actualSay = response.response && response.response.outputSpeech ? response.response.outputSpeech.ssml : undefined;\n\t\t\t\tvar actualReprompt = response.response && response.response.reprompt && response.response.reprompt.outputSpeech ? response.response.reprompt.outputSpeech.ssml : undefined;\n\t\t\t\t\n\t\t\t\t// check the returned speech\n\t\t\t\tif (currentItem.says !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'speech', actualSay);\n\t\t\t\t\tvar trimActualSay = actualSay.substring(7);\n\t\t\t\t\ttrimActualSay = trimActualSay.substring(0, trimActualSay.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.says)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"speech\", actualSay, currentItem.saysLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"speech\", actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.reprompts !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'reprompt', actualReprompt);\n\t\t\t\t\tvar trimActualReprompt = actualReprompt.substring(7);\n\t\t\t\t\ttrimActualReprompt = trimActualReprompt.substring(0, trimActualReprompt.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.reprompts)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"reprompt\", actualReprompt, currentItem.repromptsLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"reprompt\", actualReprompt);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.elicitsSlot) {\n\t\t\t\t\tlet elicitSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ElicitSlot');\n\t\t\t\t\tlet slot = elicitSlotDirective ? elicitSlotDirective.slotToElicit : '';\n\t\t\t\t\tself._assertStringEqual(context, \"elicitSlot\", slot, currentItem.elicitsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsSlot) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmSlot');\n\t\t\t\t\tlet slot = confirmSlotDirective ? confirmSlotDirective.slotToConfirm : '';\n\t\t\t\t\tself._assertStringEqual(context, \"confirmSlot\", slot, currentItem.confirmsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsIntent) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmIntent');\n\t\t\t\t\tif (!confirmSlotDirective) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not ask Alexa to confirm the intent\"});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasAttributes) {\n\t\t\t\t\tfor (let att in currentItem.hasAttributes) {\n\t\t\t\t\t\tif (currentItem.hasAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tif (typeof currentItem.hasAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!currentItem.hasAttributes[att](response.sessionAttributes[att])) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the attribute \" + att + \" did not contain the correct value. Value was: \" + response.sessionAttributes[att]});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, response.sessionAttributes[att], currentItem.hasAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardTitle) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardTitle\", response.response.card.title, currentItem.hasCardTitle);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardContent) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardContent\", response.response.card.content, currentItem.hasCardContent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardContentLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardContent\", response.response.card.content, currentItem.hasCardContentLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardText) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardText\", response.response.card.text, currentItem.hasCardText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardTextLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardText\", response.response.card.text, currentItem.hasCardTextLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasSmallImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"smallImageUrl\", response.response.card.image.smallImageUrl, currentItem.hasSmallImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasLargeImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"largeImageUrl\", response.response.card.image.largeImageUrl, currentItem.hasLargeImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// check the shouldEndSession flag\n\t\t\t\tif (currentItem.shouldEndSession === true && response.response.shouldEndSession === false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response did not end the session\",\n\t\t\t\t\t\t\texpected: \"the response ends the session\",\n\t\t\t\t\t\t\tactual: \"the response did not end the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if (currentItem.shouldEndSession === false && response.response.shouldEndSession !== false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response ended the session\",\n\t\t\t\t\t\t\texpected: \"the response does not end the session\",\n\t\t\t\t\t\t\tactual: \"the response ended the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcheckAudioPlayer(self, context, response, currentItem);\n\t\t\t\t\n\t\t\t\t// custom checks\n\t\t\t\tif (currentItem.saysCallback) {\n\t\t\t\t\tcurrentItem.saysCallback(context, actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.callback) {\n\t\t\t\t\tcurrentItem.callback(context, response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// extra checks\n\t\t\t\tif (self.extraFeatures.questionMarkCheck) {\n\t\t\t\t\tcontext._questionMarkCheck(response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trun(handler, sequenceIndex + 1, response.sessionAttributes);\n\t\t\t})\n\t\t\t.catch(done);\n\t}\n};\nrun(index.handler, 0, {});",
                  "err": {},
                  "uuid": "941ef7a6-91da-4b0b-a5e3-ce7b47e688a3",
                  "parentUUID": "371cf801-3d4c-43e1-9dab-15f81d8f3907",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "941ef7a6-91da-4b0b-a5e3-ce7b47e688a3"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 2000
            },
            {
              "uuid": "330cb58a-c1e6-4a46-b30e-6a5711ab1276",
              "title": "AnswerIntent",
              "fullFile": "C:\\Users\\juanp\\Desktop\\Skill TFG\\lambda\\test.js",
              "file": "\\test.js",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "returns the correct responses",
                  "fullTitle": "TFG Skill AnswerIntent returns the correct responses",
                  "timedOut": false,
                  "duration": 1,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "var run = function (handler, sequenceIndex, attributes) {\n\tif (sequenceIndex >= sequence.length) {\n\t\t// all requests were executed\n\t\tdone();\n\t}\n\telse {\n\t\tvar ctx = awsContext(self.mockContextOptions);\n\t\tvar currentItem = sequence[sequenceIndex];\n\t\t\n\t\tvar request = currentItem.request;\n\t\trequest.session.new = sequenceIndex === 0;\n\t\tif (attributes) {\n\t\t\trequest.session.attributes = JSON.parse(JSON.stringify(attributes));\n\t\t} else {\n\t\t\trequest.session.attributes = {};\n\t\t}\n\t\trequest.session.sessionId = randomSessionId;\n\t\tvar callback = function (err, result) {\n\t\t\tif (err) {\n\t\t\t\treturn ctx.fail(err);\n\t\t\t}\n\t\t\treturn ctx.succeed(result);\n\t\t};\n\t\t// adds values from withSessionAttributes to the session\n\t\tif (currentItem.withSessionAttributes) {\n\t\t\tvar session = request.session.attributes;\n\t\t\tfor (var newAttribute in currentItem.withSessionAttributes) {\n\t\t\t\tif (!session[newAttribute]) {\n\t\t\t\t\tsession[newAttribute] = currentItem.withSessionAttributes[newAttribute];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar requestType = request.request.type;\n\t\tif (requestType === \"IntentRequest\") {\n\t\t\trequestType = request.request.intent.name;\n\t\t}\n\t\tvar context = new CallbackContext(self, sequenceIndex, locale, requestType);\n\t\t\n\t\tif (self.dynamoDBTable) {\n\t\t\tself.dynamoDBGetMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Key[self.partitionKeyName], self.userId);\n\t\t\t\t\n\t\t\t\tconst Item = {};\n\t\t\t\tItem[self.partitionKeyName] = self.userId;\n\t\t\t\tItem[self.attributesName] = currentItem.withStoredAttributes || {};\n\t\t\t\tcallback(null, {TableName: self.dynamoDBTable, Item});\n\t\t\t};\n\t\t\tself.dynamoDBPutMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Item[self.partitionKeyName], self.userId);\n\t\t\t\tlet storesAttributes = currentItem.storesAttributes;\n\t\t\t\tif (storesAttributes) {\n\t\t\t\t\tfor (let att in storesAttributes) {\n\t\t\t\t\t\tif (storesAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tconst storedAttr = params.Item[self.attributesName][att];\n\t\t\t\t\t\t\tif (typeof storesAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!storesAttributes[att](storedAttr)) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the stored attribute \" + att + \" did not contain the correct value. Value was: \" + storedAttr});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, storedAttr, storesAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback(null, {});\n\t\t\t};\n\t\t}\n\t\t\n\t\tvar result = handler(request, ctx, callback, true);\n\t\tif (result) {\n\t\t\tif (result.then) {\n\t\t\t\tresult.then(ctx.succeed, ctx.fail);\n\t\t\t} else {\n\t\t\t\tctx.succeed(result);\n\t\t\t}\n\t\t}\n\t\t\n\t\tctx.Promise\n\t\t\t.then(response => {\n\t\t\t\t//TODO: null checks\n\t\t\t\t\n\t\t\t\tif (response.toJSON) {\n\t\t\t\t\tresponse = response.toJSON();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar actualSay = response.response && response.response.outputSpeech ? response.response.outputSpeech.ssml : undefined;\n\t\t\t\tvar actualReprompt = response.response && response.response.reprompt && response.response.reprompt.outputSpeech ? response.response.reprompt.outputSpeech.ssml : undefined;\n\t\t\t\t\n\t\t\t\t// check the returned speech\n\t\t\t\tif (currentItem.says !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'speech', actualSay);\n\t\t\t\t\tvar trimActualSay = actualSay.substring(7);\n\t\t\t\t\ttrimActualSay = trimActualSay.substring(0, trimActualSay.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.says)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"speech\", actualSay, currentItem.saysLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"speech\", actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.reprompts !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'reprompt', actualReprompt);\n\t\t\t\t\tvar trimActualReprompt = actualReprompt.substring(7);\n\t\t\t\t\ttrimActualReprompt = trimActualReprompt.substring(0, trimActualReprompt.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.reprompts)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"reprompt\", actualReprompt, currentItem.repromptsLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"reprompt\", actualReprompt);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.elicitsSlot) {\n\t\t\t\t\tlet elicitSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ElicitSlot');\n\t\t\t\t\tlet slot = elicitSlotDirective ? elicitSlotDirective.slotToElicit : '';\n\t\t\t\t\tself._assertStringEqual(context, \"elicitSlot\", slot, currentItem.elicitsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsSlot) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmSlot');\n\t\t\t\t\tlet slot = confirmSlotDirective ? confirmSlotDirective.slotToConfirm : '';\n\t\t\t\t\tself._assertStringEqual(context, \"confirmSlot\", slot, currentItem.confirmsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsIntent) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmIntent');\n\t\t\t\t\tif (!confirmSlotDirective) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not ask Alexa to confirm the intent\"});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasAttributes) {\n\t\t\t\t\tfor (let att in currentItem.hasAttributes) {\n\t\t\t\t\t\tif (currentItem.hasAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tif (typeof currentItem.hasAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!currentItem.hasAttributes[att](response.sessionAttributes[att])) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the attribute \" + att + \" did not contain the correct value. Value was: \" + response.sessionAttributes[att]});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, response.sessionAttributes[att], currentItem.hasAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardTitle) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardTitle\", response.response.card.title, currentItem.hasCardTitle);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardContent) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardContent\", response.response.card.content, currentItem.hasCardContent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardContentLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardContent\", response.response.card.content, currentItem.hasCardContentLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardText) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardText\", response.response.card.text, currentItem.hasCardText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardTextLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardText\", response.response.card.text, currentItem.hasCardTextLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasSmallImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"smallImageUrl\", response.response.card.image.smallImageUrl, currentItem.hasSmallImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasLargeImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"largeImageUrl\", response.response.card.image.largeImageUrl, currentItem.hasLargeImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// check the shouldEndSession flag\n\t\t\t\tif (currentItem.shouldEndSession === true && response.response.shouldEndSession === false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response did not end the session\",\n\t\t\t\t\t\t\texpected: \"the response ends the session\",\n\t\t\t\t\t\t\tactual: \"the response did not end the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if (currentItem.shouldEndSession === false && response.response.shouldEndSession !== false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response ended the session\",\n\t\t\t\t\t\t\texpected: \"the response does not end the session\",\n\t\t\t\t\t\t\tactual: \"the response ended the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcheckAudioPlayer(self, context, response, currentItem);\n\t\t\t\t\n\t\t\t\t// custom checks\n\t\t\t\tif (currentItem.saysCallback) {\n\t\t\t\t\tcurrentItem.saysCallback(context, actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.callback) {\n\t\t\t\t\tcurrentItem.callback(context, response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// extra checks\n\t\t\t\tif (self.extraFeatures.questionMarkCheck) {\n\t\t\t\t\tcontext._questionMarkCheck(response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trun(handler, sequenceIndex + 1, response.sessionAttributes);\n\t\t\t})\n\t\t\t.catch(done);\n\t}\n};\nrun(index.handler, 0, {});",
                  "err": {},
                  "uuid": "1c540c8d-eba9-46b6-a5a4-ac21f9662917",
                  "parentUUID": "330cb58a-c1e6-4a46-b30e-6a5711ab1276",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "1c540c8d-eba9-46b6-a5a4-ac21f9662917"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 1,
              "root": false,
              "rootEmpty": false,
              "_timeout": 2000
            },
            {
              "uuid": "964a49bd-6549-4b12-bce5-74838464086f",
              "title": "AMAZON.RepeatIntent",
              "fullFile": "C:\\Users\\juanp\\Desktop\\Skill TFG\\lambda\\test.js",
              "file": "\\test.js",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "returns the correct responses",
                  "fullTitle": "TFG Skill AMAZON.RepeatIntent returns the correct responses",
                  "timedOut": false,
                  "duration": 0,
                  "state": "failed",
                  "speed": null,
                  "pass": false,
                  "fail": true,
                  "pending": false,
                  "context": null,
                  "code": "var run = function (handler, sequenceIndex, attributes) {\n\tif (sequenceIndex >= sequence.length) {\n\t\t// all requests were executed\n\t\tdone();\n\t}\n\telse {\n\t\tvar ctx = awsContext(self.mockContextOptions);\n\t\tvar currentItem = sequence[sequenceIndex];\n\t\t\n\t\tvar request = currentItem.request;\n\t\trequest.session.new = sequenceIndex === 0;\n\t\tif (attributes) {\n\t\t\trequest.session.attributes = JSON.parse(JSON.stringify(attributes));\n\t\t} else {\n\t\t\trequest.session.attributes = {};\n\t\t}\n\t\trequest.session.sessionId = randomSessionId;\n\t\tvar callback = function (err, result) {\n\t\t\tif (err) {\n\t\t\t\treturn ctx.fail(err);\n\t\t\t}\n\t\t\treturn ctx.succeed(result);\n\t\t};\n\t\t// adds values from withSessionAttributes to the session\n\t\tif (currentItem.withSessionAttributes) {\n\t\t\tvar session = request.session.attributes;\n\t\t\tfor (var newAttribute in currentItem.withSessionAttributes) {\n\t\t\t\tif (!session[newAttribute]) {\n\t\t\t\t\tsession[newAttribute] = currentItem.withSessionAttributes[newAttribute];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar requestType = request.request.type;\n\t\tif (requestType === \"IntentRequest\") {\n\t\t\trequestType = request.request.intent.name;\n\t\t}\n\t\tvar context = new CallbackContext(self, sequenceIndex, locale, requestType);\n\t\t\n\t\tif (self.dynamoDBTable) {\n\t\t\tself.dynamoDBGetMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Key[self.partitionKeyName], self.userId);\n\t\t\t\t\n\t\t\t\tconst Item = {};\n\t\t\t\tItem[self.partitionKeyName] = self.userId;\n\t\t\t\tItem[self.attributesName] = currentItem.withStoredAttributes || {};\n\t\t\t\tcallback(null, {TableName: self.dynamoDBTable, Item});\n\t\t\t};\n\t\t\tself.dynamoDBPutMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Item[self.partitionKeyName], self.userId);\n\t\t\t\tlet storesAttributes = currentItem.storesAttributes;\n\t\t\t\tif (storesAttributes) {\n\t\t\t\t\tfor (let att in storesAttributes) {\n\t\t\t\t\t\tif (storesAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tconst storedAttr = params.Item[self.attributesName][att];\n\t\t\t\t\t\t\tif (typeof storesAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!storesAttributes[att](storedAttr)) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the stored attribute \" + att + \" did not contain the correct value. Value was: \" + storedAttr});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, storedAttr, storesAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback(null, {});\n\t\t\t};\n\t\t}\n\t\t\n\t\tvar result = handler(request, ctx, callback, true);\n\t\tif (result) {\n\t\t\tif (result.then) {\n\t\t\t\tresult.then(ctx.succeed, ctx.fail);\n\t\t\t} else {\n\t\t\t\tctx.succeed(result);\n\t\t\t}\n\t\t}\n\t\t\n\t\tctx.Promise\n\t\t\t.then(response => {\n\t\t\t\t//TODO: null checks\n\t\t\t\t\n\t\t\t\tif (response.toJSON) {\n\t\t\t\t\tresponse = response.toJSON();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar actualSay = response.response && response.response.outputSpeech ? response.response.outputSpeech.ssml : undefined;\n\t\t\t\tvar actualReprompt = response.response && response.response.reprompt && response.response.reprompt.outputSpeech ? response.response.reprompt.outputSpeech.ssml : undefined;\n\t\t\t\t\n\t\t\t\t// check the returned speech\n\t\t\t\tif (currentItem.says !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'speech', actualSay);\n\t\t\t\t\tvar trimActualSay = actualSay.substring(7);\n\t\t\t\t\ttrimActualSay = trimActualSay.substring(0, trimActualSay.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.says)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"speech\", actualSay, currentItem.saysLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"speech\", actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.reprompts !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'reprompt', actualReprompt);\n\t\t\t\t\tvar trimActualReprompt = actualReprompt.substring(7);\n\t\t\t\t\ttrimActualReprompt = trimActualReprompt.substring(0, trimActualReprompt.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.reprompts)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"reprompt\", actualReprompt, currentItem.repromptsLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"reprompt\", actualReprompt);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.elicitsSlot) {\n\t\t\t\t\tlet elicitSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ElicitSlot');\n\t\t\t\t\tlet slot = elicitSlotDirective ? elicitSlotDirective.slotToElicit : '';\n\t\t\t\t\tself._assertStringEqual(context, \"elicitSlot\", slot, currentItem.elicitsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsSlot) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmSlot');\n\t\t\t\t\tlet slot = confirmSlotDirective ? confirmSlotDirective.slotToConfirm : '';\n\t\t\t\t\tself._assertStringEqual(context, \"confirmSlot\", slot, currentItem.confirmsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsIntent) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmIntent');\n\t\t\t\t\tif (!confirmSlotDirective) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not ask Alexa to confirm the intent\"});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasAttributes) {\n\t\t\t\t\tfor (let att in currentItem.hasAttributes) {\n\t\t\t\t\t\tif (currentItem.hasAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tif (typeof currentItem.hasAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!currentItem.hasAttributes[att](response.sessionAttributes[att])) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the attribute \" + att + \" did not contain the correct value. Value was: \" + response.sessionAttributes[att]});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, response.sessionAttributes[att], currentItem.hasAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardTitle) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardTitle\", response.response.card.title, currentItem.hasCardTitle);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardContent) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardContent\", response.response.card.content, currentItem.hasCardContent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardContentLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardContent\", response.response.card.content, currentItem.hasCardContentLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardText) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardText\", response.response.card.text, currentItem.hasCardText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardTextLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardText\", response.response.card.text, currentItem.hasCardTextLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasSmallImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"smallImageUrl\", response.response.card.image.smallImageUrl, currentItem.hasSmallImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasLargeImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"largeImageUrl\", response.response.card.image.largeImageUrl, currentItem.hasLargeImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// check the shouldEndSession flag\n\t\t\t\tif (currentItem.shouldEndSession === true && response.response.shouldEndSession === false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response did not end the session\",\n\t\t\t\t\t\t\texpected: \"the response ends the session\",\n\t\t\t\t\t\t\tactual: \"the response did not end the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if (currentItem.shouldEndSession === false && response.response.shouldEndSession !== false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response ended the session\",\n\t\t\t\t\t\t\texpected: \"the response does not end the session\",\n\t\t\t\t\t\t\tactual: \"the response ended the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcheckAudioPlayer(self, context, response, currentItem);\n\t\t\t\t\n\t\t\t\t// custom checks\n\t\t\t\tif (currentItem.saysCallback) {\n\t\t\t\t\tcurrentItem.saysCallback(context, actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.callback) {\n\t\t\t\t\tcurrentItem.callback(context, response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// extra checks\n\t\t\t\tif (self.extraFeatures.questionMarkCheck) {\n\t\t\t\t\tcontext._questionMarkCheck(response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trun(handler, sequenceIndex + 1, response.sessionAttributes);\n\t\t\t})\n\t\t\t.catch(done);\n\t}\n};\nrun(index.handler, 0, {});",
                  "err": {
                    "message": "AssertionError: Request #1 (AMAZON.RepeatIntent): Possible Certification Problem: The response keeps the session open but does not contain a question mark.",
                    "estack": "AssertionError: Request #1 (AMAZON.RepeatIntent): Possible Certification Problem: The response keeps the session open but does not contain a question mark.\n    at Object._assert (node_modules\\alexa-skill-test-framework\\index.js:845:9)\n    at CallbackContext.assert (node_modules\\alexa-skill-test-framework\\index.js:39:17)\n    at CallbackContext._questionMarkCheck (node_modules\\alexa-skill-test-framework\\index.js:64:8)\n    at C:\\Users\\juanp\\Desktop\\Skill TFG\\lambda\\node_modules\\alexa-skill-test-framework\\index.js:728:17",
                    "diff": null
                  },
                  "uuid": "96cf5f69-5b01-4b8a-9e00-0882516fd214",
                  "parentUUID": "964a49bd-6549-4b12-bce5-74838464086f",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [],
              "failures": [
                "96cf5f69-5b01-4b8a-9e00-0882516fd214"
              ],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 2000
            },
            {
              "uuid": "6b48d7a9-0bc7-4937-8155-f3b5dbcda594",
              "title": "AMAZON.YesIntent into AMAZON.NoIntent",
              "fullFile": "C:\\Users\\juanp\\Desktop\\Skill TFG\\lambda\\test.js",
              "file": "\\test.js",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "returns the correct responses",
                  "fullTitle": "TFG Skill AMAZON.YesIntent into AMAZON.NoIntent returns the correct responses",
                  "timedOut": false,
                  "duration": 3,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "var run = function (handler, sequenceIndex, attributes) {\n\tif (sequenceIndex >= sequence.length) {\n\t\t// all requests were executed\n\t\tdone();\n\t}\n\telse {\n\t\tvar ctx = awsContext(self.mockContextOptions);\n\t\tvar currentItem = sequence[sequenceIndex];\n\t\t\n\t\tvar request = currentItem.request;\n\t\trequest.session.new = sequenceIndex === 0;\n\t\tif (attributes) {\n\t\t\trequest.session.attributes = JSON.parse(JSON.stringify(attributes));\n\t\t} else {\n\t\t\trequest.session.attributes = {};\n\t\t}\n\t\trequest.session.sessionId = randomSessionId;\n\t\tvar callback = function (err, result) {\n\t\t\tif (err) {\n\t\t\t\treturn ctx.fail(err);\n\t\t\t}\n\t\t\treturn ctx.succeed(result);\n\t\t};\n\t\t// adds values from withSessionAttributes to the session\n\t\tif (currentItem.withSessionAttributes) {\n\t\t\tvar session = request.session.attributes;\n\t\t\tfor (var newAttribute in currentItem.withSessionAttributes) {\n\t\t\t\tif (!session[newAttribute]) {\n\t\t\t\t\tsession[newAttribute] = currentItem.withSessionAttributes[newAttribute];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar requestType = request.request.type;\n\t\tif (requestType === \"IntentRequest\") {\n\t\t\trequestType = request.request.intent.name;\n\t\t}\n\t\tvar context = new CallbackContext(self, sequenceIndex, locale, requestType);\n\t\t\n\t\tif (self.dynamoDBTable) {\n\t\t\tself.dynamoDBGetMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Key[self.partitionKeyName], self.userId);\n\t\t\t\t\n\t\t\t\tconst Item = {};\n\t\t\t\tItem[self.partitionKeyName] = self.userId;\n\t\t\t\tItem[self.attributesName] = currentItem.withStoredAttributes || {};\n\t\t\t\tcallback(null, {TableName: self.dynamoDBTable, Item});\n\t\t\t};\n\t\t\tself.dynamoDBPutMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Item[self.partitionKeyName], self.userId);\n\t\t\t\tlet storesAttributes = currentItem.storesAttributes;\n\t\t\t\tif (storesAttributes) {\n\t\t\t\t\tfor (let att in storesAttributes) {\n\t\t\t\t\t\tif (storesAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tconst storedAttr = params.Item[self.attributesName][att];\n\t\t\t\t\t\t\tif (typeof storesAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!storesAttributes[att](storedAttr)) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the stored attribute \" + att + \" did not contain the correct value. Value was: \" + storedAttr});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, storedAttr, storesAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback(null, {});\n\t\t\t};\n\t\t}\n\t\t\n\t\tvar result = handler(request, ctx, callback, true);\n\t\tif (result) {\n\t\t\tif (result.then) {\n\t\t\t\tresult.then(ctx.succeed, ctx.fail);\n\t\t\t} else {\n\t\t\t\tctx.succeed(result);\n\t\t\t}\n\t\t}\n\t\t\n\t\tctx.Promise\n\t\t\t.then(response => {\n\t\t\t\t//TODO: null checks\n\t\t\t\t\n\t\t\t\tif (response.toJSON) {\n\t\t\t\t\tresponse = response.toJSON();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar actualSay = response.response && response.response.outputSpeech ? response.response.outputSpeech.ssml : undefined;\n\t\t\t\tvar actualReprompt = response.response && response.response.reprompt && response.response.reprompt.outputSpeech ? response.response.reprompt.outputSpeech.ssml : undefined;\n\t\t\t\t\n\t\t\t\t// check the returned speech\n\t\t\t\tif (currentItem.says !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'speech', actualSay);\n\t\t\t\t\tvar trimActualSay = actualSay.substring(7);\n\t\t\t\t\ttrimActualSay = trimActualSay.substring(0, trimActualSay.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.says)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"speech\", actualSay, currentItem.saysLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"speech\", actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.reprompts !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'reprompt', actualReprompt);\n\t\t\t\t\tvar trimActualReprompt = actualReprompt.substring(7);\n\t\t\t\t\ttrimActualReprompt = trimActualReprompt.substring(0, trimActualReprompt.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.reprompts)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"reprompt\", actualReprompt, currentItem.repromptsLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"reprompt\", actualReprompt);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.elicitsSlot) {\n\t\t\t\t\tlet elicitSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ElicitSlot');\n\t\t\t\t\tlet slot = elicitSlotDirective ? elicitSlotDirective.slotToElicit : '';\n\t\t\t\t\tself._assertStringEqual(context, \"elicitSlot\", slot, currentItem.elicitsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsSlot) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmSlot');\n\t\t\t\t\tlet slot = confirmSlotDirective ? confirmSlotDirective.slotToConfirm : '';\n\t\t\t\t\tself._assertStringEqual(context, \"confirmSlot\", slot, currentItem.confirmsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsIntent) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmIntent');\n\t\t\t\t\tif (!confirmSlotDirective) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not ask Alexa to confirm the intent\"});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasAttributes) {\n\t\t\t\t\tfor (let att in currentItem.hasAttributes) {\n\t\t\t\t\t\tif (currentItem.hasAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tif (typeof currentItem.hasAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!currentItem.hasAttributes[att](response.sessionAttributes[att])) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the attribute \" + att + \" did not contain the correct value. Value was: \" + response.sessionAttributes[att]});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, response.sessionAttributes[att], currentItem.hasAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardTitle) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardTitle\", response.response.card.title, currentItem.hasCardTitle);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardContent) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardContent\", response.response.card.content, currentItem.hasCardContent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardContentLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardContent\", response.response.card.content, currentItem.hasCardContentLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardText) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardText\", response.response.card.text, currentItem.hasCardText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardTextLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardText\", response.response.card.text, currentItem.hasCardTextLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasSmallImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"smallImageUrl\", response.response.card.image.smallImageUrl, currentItem.hasSmallImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasLargeImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"largeImageUrl\", response.response.card.image.largeImageUrl, currentItem.hasLargeImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// check the shouldEndSession flag\n\t\t\t\tif (currentItem.shouldEndSession === true && response.response.shouldEndSession === false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response did not end the session\",\n\t\t\t\t\t\t\texpected: \"the response ends the session\",\n\t\t\t\t\t\t\tactual: \"the response did not end the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if (currentItem.shouldEndSession === false && response.response.shouldEndSession !== false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response ended the session\",\n\t\t\t\t\t\t\texpected: \"the response does not end the session\",\n\t\t\t\t\t\t\tactual: \"the response ended the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcheckAudioPlayer(self, context, response, currentItem);\n\t\t\t\t\n\t\t\t\t// custom checks\n\t\t\t\tif (currentItem.saysCallback) {\n\t\t\t\t\tcurrentItem.saysCallback(context, actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.callback) {\n\t\t\t\t\tcurrentItem.callback(context, response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// extra checks\n\t\t\t\tif (self.extraFeatures.questionMarkCheck) {\n\t\t\t\t\tcontext._questionMarkCheck(response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trun(handler, sequenceIndex + 1, response.sessionAttributes);\n\t\t\t})\n\t\t\t.catch(done);\n\t}\n};\nrun(index.handler, 0, {});",
                  "err": {},
                  "uuid": "1c1f4085-974c-4460-adf7-d236376f50e3",
                  "parentUUID": "6b48d7a9-0bc7-4937-8155-f3b5dbcda594",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "1c1f4085-974c-4460-adf7-d236376f50e3"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 3,
              "root": false,
              "rootEmpty": false,
              "_timeout": 2000
            },
            {
              "uuid": "7e7bf668-b24b-4fe2-9cdb-fcd8606b3b80",
              "title": "AMAZON.HelpIntent",
              "fullFile": "C:\\Users\\juanp\\Desktop\\Skill TFG\\lambda\\test.js",
              "file": "\\test.js",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "returns the correct responses",
                  "fullTitle": "TFG Skill AMAZON.HelpIntent returns the correct responses",
                  "timedOut": false,
                  "duration": 0,
                  "state": "failed",
                  "speed": null,
                  "pass": false,
                  "fail": true,
                  "pending": false,
                  "context": null,
                  "code": "var run = function (handler, sequenceIndex, attributes) {\n\tif (sequenceIndex >= sequence.length) {\n\t\t// all requests were executed\n\t\tdone();\n\t}\n\telse {\n\t\tvar ctx = awsContext(self.mockContextOptions);\n\t\tvar currentItem = sequence[sequenceIndex];\n\t\t\n\t\tvar request = currentItem.request;\n\t\trequest.session.new = sequenceIndex === 0;\n\t\tif (attributes) {\n\t\t\trequest.session.attributes = JSON.parse(JSON.stringify(attributes));\n\t\t} else {\n\t\t\trequest.session.attributes = {};\n\t\t}\n\t\trequest.session.sessionId = randomSessionId;\n\t\tvar callback = function (err, result) {\n\t\t\tif (err) {\n\t\t\t\treturn ctx.fail(err);\n\t\t\t}\n\t\t\treturn ctx.succeed(result);\n\t\t};\n\t\t// adds values from withSessionAttributes to the session\n\t\tif (currentItem.withSessionAttributes) {\n\t\t\tvar session = request.session.attributes;\n\t\t\tfor (var newAttribute in currentItem.withSessionAttributes) {\n\t\t\t\tif (!session[newAttribute]) {\n\t\t\t\t\tsession[newAttribute] = currentItem.withSessionAttributes[newAttribute];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar requestType = request.request.type;\n\t\tif (requestType === \"IntentRequest\") {\n\t\t\trequestType = request.request.intent.name;\n\t\t}\n\t\tvar context = new CallbackContext(self, sequenceIndex, locale, requestType);\n\t\t\n\t\tif (self.dynamoDBTable) {\n\t\t\tself.dynamoDBGetMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Key[self.partitionKeyName], self.userId);\n\t\t\t\t\n\t\t\t\tconst Item = {};\n\t\t\t\tItem[self.partitionKeyName] = self.userId;\n\t\t\t\tItem[self.attributesName] = currentItem.withStoredAttributes || {};\n\t\t\t\tcallback(null, {TableName: self.dynamoDBTable, Item});\n\t\t\t};\n\t\t\tself.dynamoDBPutMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Item[self.partitionKeyName], self.userId);\n\t\t\t\tlet storesAttributes = currentItem.storesAttributes;\n\t\t\t\tif (storesAttributes) {\n\t\t\t\t\tfor (let att in storesAttributes) {\n\t\t\t\t\t\tif (storesAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tconst storedAttr = params.Item[self.attributesName][att];\n\t\t\t\t\t\t\tif (typeof storesAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!storesAttributes[att](storedAttr)) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the stored attribute \" + att + \" did not contain the correct value. Value was: \" + storedAttr});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, storedAttr, storesAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback(null, {});\n\t\t\t};\n\t\t}\n\t\t\n\t\tvar result = handler(request, ctx, callback, true);\n\t\tif (result) {\n\t\t\tif (result.then) {\n\t\t\t\tresult.then(ctx.succeed, ctx.fail);\n\t\t\t} else {\n\t\t\t\tctx.succeed(result);\n\t\t\t}\n\t\t}\n\t\t\n\t\tctx.Promise\n\t\t\t.then(response => {\n\t\t\t\t//TODO: null checks\n\t\t\t\t\n\t\t\t\tif (response.toJSON) {\n\t\t\t\t\tresponse = response.toJSON();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar actualSay = response.response && response.response.outputSpeech ? response.response.outputSpeech.ssml : undefined;\n\t\t\t\tvar actualReprompt = response.response && response.response.reprompt && response.response.reprompt.outputSpeech ? response.response.reprompt.outputSpeech.ssml : undefined;\n\t\t\t\t\n\t\t\t\t// check the returned speech\n\t\t\t\tif (currentItem.says !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'speech', actualSay);\n\t\t\t\t\tvar trimActualSay = actualSay.substring(7);\n\t\t\t\t\ttrimActualSay = trimActualSay.substring(0, trimActualSay.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.says)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"speech\", actualSay, currentItem.saysLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"speech\", actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.reprompts !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'reprompt', actualReprompt);\n\t\t\t\t\tvar trimActualReprompt = actualReprompt.substring(7);\n\t\t\t\t\ttrimActualReprompt = trimActualReprompt.substring(0, trimActualReprompt.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.reprompts)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"reprompt\", actualReprompt, currentItem.repromptsLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"reprompt\", actualReprompt);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.elicitsSlot) {\n\t\t\t\t\tlet elicitSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ElicitSlot');\n\t\t\t\t\tlet slot = elicitSlotDirective ? elicitSlotDirective.slotToElicit : '';\n\t\t\t\t\tself._assertStringEqual(context, \"elicitSlot\", slot, currentItem.elicitsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsSlot) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmSlot');\n\t\t\t\t\tlet slot = confirmSlotDirective ? confirmSlotDirective.slotToConfirm : '';\n\t\t\t\t\tself._assertStringEqual(context, \"confirmSlot\", slot, currentItem.confirmsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsIntent) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmIntent');\n\t\t\t\t\tif (!confirmSlotDirective) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not ask Alexa to confirm the intent\"});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasAttributes) {\n\t\t\t\t\tfor (let att in currentItem.hasAttributes) {\n\t\t\t\t\t\tif (currentItem.hasAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tif (typeof currentItem.hasAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!currentItem.hasAttributes[att](response.sessionAttributes[att])) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the attribute \" + att + \" did not contain the correct value. Value was: \" + response.sessionAttributes[att]});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, response.sessionAttributes[att], currentItem.hasAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardTitle) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardTitle\", response.response.card.title, currentItem.hasCardTitle);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardContent) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardContent\", response.response.card.content, currentItem.hasCardContent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardContentLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardContent\", response.response.card.content, currentItem.hasCardContentLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardText) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardText\", response.response.card.text, currentItem.hasCardText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardTextLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardText\", response.response.card.text, currentItem.hasCardTextLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasSmallImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"smallImageUrl\", response.response.card.image.smallImageUrl, currentItem.hasSmallImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasLargeImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"largeImageUrl\", response.response.card.image.largeImageUrl, currentItem.hasLargeImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// check the shouldEndSession flag\n\t\t\t\tif (currentItem.shouldEndSession === true && response.response.shouldEndSession === false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response did not end the session\",\n\t\t\t\t\t\t\texpected: \"the response ends the session\",\n\t\t\t\t\t\t\tactual: \"the response did not end the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if (currentItem.shouldEndSession === false && response.response.shouldEndSession !== false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response ended the session\",\n\t\t\t\t\t\t\texpected: \"the response does not end the session\",\n\t\t\t\t\t\t\tactual: \"the response ended the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcheckAudioPlayer(self, context, response, currentItem);\n\t\t\t\t\n\t\t\t\t// custom checks\n\t\t\t\tif (currentItem.saysCallback) {\n\t\t\t\t\tcurrentItem.saysCallback(context, actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.callback) {\n\t\t\t\t\tcurrentItem.callback(context, response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// extra checks\n\t\t\t\tif (self.extraFeatures.questionMarkCheck) {\n\t\t\t\t\tcontext._questionMarkCheck(response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trun(handler, sequenceIndex + 1, response.sessionAttributes);\n\t\t\t})\n\t\t\t.catch(done);\n\t}\n};\nrun(index.handler, 0, {});",
                  "err": {
                    "message": "AssertionError: Request #1 (AMAZON.HelpIntent): Possible Certification Problem: The response keeps the session open but does not contain a question mark.",
                    "estack": "AssertionError: Request #1 (AMAZON.HelpIntent): Possible Certification Problem: The response keeps the session open but does not contain a question mark.\n    at Object._assert (node_modules\\alexa-skill-test-framework\\index.js:845:9)\n    at CallbackContext.assert (node_modules\\alexa-skill-test-framework\\index.js:39:17)\n    at CallbackContext._questionMarkCheck (node_modules\\alexa-skill-test-framework\\index.js:64:8)\n    at C:\\Users\\juanp\\Desktop\\Skill TFG\\lambda\\node_modules\\alexa-skill-test-framework\\index.js:728:17",
                    "diff": null
                  },
                  "uuid": "91987340-33a1-4e24-9202-0b4e29cb5db8",
                  "parentUUID": "7e7bf668-b24b-4fe2-9cdb-fcd8606b3b80",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [],
              "failures": [
                "91987340-33a1-4e24-9202-0b4e29cb5db8"
              ],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 2000
            },
            {
              "uuid": "70e7e4a5-3354-46ce-95f0-f7cbeb421447",
              "title": "AMAZON.CancelIntent into AMAZON.StopIntent",
              "fullFile": "C:\\Users\\juanp\\Desktop\\Skill TFG\\lambda\\test.js",
              "file": "\\test.js",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "returns the correct responses",
                  "fullTitle": "TFG Skill AMAZON.CancelIntent into AMAZON.StopIntent returns the correct responses",
                  "timedOut": false,
                  "duration": 0,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "var run = function (handler, sequenceIndex, attributes) {\n\tif (sequenceIndex >= sequence.length) {\n\t\t// all requests were executed\n\t\tdone();\n\t}\n\telse {\n\t\tvar ctx = awsContext(self.mockContextOptions);\n\t\tvar currentItem = sequence[sequenceIndex];\n\t\t\n\t\tvar request = currentItem.request;\n\t\trequest.session.new = sequenceIndex === 0;\n\t\tif (attributes) {\n\t\t\trequest.session.attributes = JSON.parse(JSON.stringify(attributes));\n\t\t} else {\n\t\t\trequest.session.attributes = {};\n\t\t}\n\t\trequest.session.sessionId = randomSessionId;\n\t\tvar callback = function (err, result) {\n\t\t\tif (err) {\n\t\t\t\treturn ctx.fail(err);\n\t\t\t}\n\t\t\treturn ctx.succeed(result);\n\t\t};\n\t\t// adds values from withSessionAttributes to the session\n\t\tif (currentItem.withSessionAttributes) {\n\t\t\tvar session = request.session.attributes;\n\t\t\tfor (var newAttribute in currentItem.withSessionAttributes) {\n\t\t\t\tif (!session[newAttribute]) {\n\t\t\t\t\tsession[newAttribute] = currentItem.withSessionAttributes[newAttribute];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar requestType = request.request.type;\n\t\tif (requestType === \"IntentRequest\") {\n\t\t\trequestType = request.request.intent.name;\n\t\t}\n\t\tvar context = new CallbackContext(self, sequenceIndex, locale, requestType);\n\t\t\n\t\tif (self.dynamoDBTable) {\n\t\t\tself.dynamoDBGetMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Key[self.partitionKeyName], self.userId);\n\t\t\t\t\n\t\t\t\tconst Item = {};\n\t\t\t\tItem[self.partitionKeyName] = self.userId;\n\t\t\t\tItem[self.attributesName] = currentItem.withStoredAttributes || {};\n\t\t\t\tcallback(null, {TableName: self.dynamoDBTable, Item});\n\t\t\t};\n\t\t\tself.dynamoDBPutMock = (params, callback) => {\n\t\t\t\tself._assertStringEqual(context, \"TableName\", params.TableName, self.dynamoDBTable);\n\t\t\t\tself._assertStringEqual(context, \"UserId\", params.Item[self.partitionKeyName], self.userId);\n\t\t\t\tlet storesAttributes = currentItem.storesAttributes;\n\t\t\t\tif (storesAttributes) {\n\t\t\t\t\tfor (let att in storesAttributes) {\n\t\t\t\t\t\tif (storesAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tconst storedAttr = params.Item[self.attributesName][att];\n\t\t\t\t\t\t\tif (typeof storesAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!storesAttributes[att](storedAttr)) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the stored attribute \" + att + \" did not contain the correct value. Value was: \" + storedAttr});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, storedAttr, storesAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback(null, {});\n\t\t\t};\n\t\t}\n\t\t\n\t\tvar result = handler(request, ctx, callback, true);\n\t\tif (result) {\n\t\t\tif (result.then) {\n\t\t\t\tresult.then(ctx.succeed, ctx.fail);\n\t\t\t} else {\n\t\t\t\tctx.succeed(result);\n\t\t\t}\n\t\t}\n\t\t\n\t\tctx.Promise\n\t\t\t.then(response => {\n\t\t\t\t//TODO: null checks\n\t\t\t\t\n\t\t\t\tif (response.toJSON) {\n\t\t\t\t\tresponse = response.toJSON();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar actualSay = response.response && response.response.outputSpeech ? response.response.outputSpeech.ssml : undefined;\n\t\t\t\tvar actualReprompt = response.response && response.response.reprompt && response.response.reprompt.outputSpeech ? response.response.reprompt.outputSpeech.ssml : undefined;\n\t\t\t\t\n\t\t\t\t// check the returned speech\n\t\t\t\tif (currentItem.says !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'speech', actualSay);\n\t\t\t\t\tvar trimActualSay = actualSay.substring(7);\n\t\t\t\t\ttrimActualSay = trimActualSay.substring(0, trimActualSay.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.says)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"speech\", trimActualSay, currentItem.says);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"speech\", actualSay, currentItem.saysLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.saysNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"speech\", actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.reprompts !== undefined) {\n\t\t\t\t\tself._assertStringPresent(context, 'reprompt', actualReprompt);\n\t\t\t\t\tvar trimActualReprompt = actualReprompt.substring(7);\n\t\t\t\t\ttrimActualReprompt = trimActualReprompt.substring(0, trimActualReprompt.length - 8).trim();\n\t\t\t\t\tif (Array.isArray(currentItem.reprompts)) {\n\t\t\t\t\t\tself._assertStringOneOf(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"reprompt\", trimActualReprompt, currentItem.reprompts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsLike !== undefined) {\n\t\t\t\t\tself._assertStringContains(context, \"reprompt\", actualReprompt, currentItem.repromptsLike);\n\t\t\t\t}\n\t\t\t\tif (currentItem.repromptsNothing) {\n\t\t\t\t\tself._assertStringMissing(context, \"reprompt\", actualReprompt);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.elicitsSlot) {\n\t\t\t\t\tlet elicitSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ElicitSlot');\n\t\t\t\t\tlet slot = elicitSlotDirective ? elicitSlotDirective.slotToElicit : '';\n\t\t\t\t\tself._assertStringEqual(context, \"elicitSlot\", slot, currentItem.elicitsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsSlot) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmSlot');\n\t\t\t\t\tlet slot = confirmSlotDirective ? confirmSlotDirective.slotToConfirm : '';\n\t\t\t\t\tself._assertStringEqual(context, \"confirmSlot\", slot, currentItem.confirmsSlot);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.confirmsIntent) {\n\t\t\t\t\tlet confirmSlotDirective = self._getDirectiveFromResponse(response, 'Dialog.ConfirmIntent');\n\t\t\t\t\tif (!confirmSlotDirective) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not ask Alexa to confirm the intent\"});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasAttributes) {\n\t\t\t\t\tfor (let att in currentItem.hasAttributes) {\n\t\t\t\t\t\tif (currentItem.hasAttributes.hasOwnProperty(att)) {\n\t\t\t\t\t\t\tif (typeof currentItem.hasAttributes[att] === \"function\") {\n\t\t\t\t\t\t\t\tif (!currentItem.hasAttributes[att](response.sessionAttributes[att])) {\n\t\t\t\t\t\t\t\t\tcontext.assert({message: \"the attribute \" + att + \" did not contain the correct value. Value was: \" + response.sessionAttributes[att]});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself._assertStringEqual(context, att, response.sessionAttributes[att], currentItem.hasAttributes[att]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardTitle) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardTitle\", response.response.card.title, currentItem.hasCardTitle);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (currentItem.hasCardContent) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({message: \"the response did not contain a card\"});\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardContent\", response.response.card.content, currentItem.hasCardContent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardContentLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Simple\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a simple card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardContent\", response.response.card.content, currentItem.hasCardContentLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardText) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringEqual(context, \"cardText\", response.response.card.text, currentItem.hasCardText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasCardTextLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"cardText\", response.response.card.text, currentItem.hasCardTextLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasSmallImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"smallImageUrl\", response.response.card.image.smallImageUrl, currentItem.hasSmallImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentItem.hasLargeImageUrlLike) {\n\t\t\t\t\tif (!response.response.card) {\n\t\t\t\t\t\tcontext.assert({ message: \"the response did not contain a card\" });\n\t\t\t\t\t} else if (response.response.card.type !== \"Standard\") {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response was not a standard card\" });\n\t\t\t\t\t} else if (!response.response.card.image) {\n\t\t\t\t\t\tcontext.assert({ message: \"the card in the response did not contain an image\" });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._assertStringContains(context, \"largeImageUrl\", response.response.card.image.largeImageUrl, currentItem.hasLargeImageUrlLike);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// check the shouldEndSession flag\n\t\t\t\tif (currentItem.shouldEndSession === true && response.response.shouldEndSession === false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response did not end the session\",\n\t\t\t\t\t\t\texpected: \"the response ends the session\",\n\t\t\t\t\t\t\tactual: \"the response did not end the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if (currentItem.shouldEndSession === false && response.response.shouldEndSession !== false) {\n\t\t\t\t\tcontext.assert(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmessage: \"the response ended the session\",\n\t\t\t\t\t\t\texpected: \"the response does not end the session\",\n\t\t\t\t\t\t\tactual: \"the response ended the session\"\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcheckAudioPlayer(self, context, response, currentItem);\n\t\t\t\t\n\t\t\t\t// custom checks\n\t\t\t\tif (currentItem.saysCallback) {\n\t\t\t\t\tcurrentItem.saysCallback(context, actualSay);\n\t\t\t\t}\n\t\t\t\tif (currentItem.callback) {\n\t\t\t\t\tcurrentItem.callback(context, response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// extra checks\n\t\t\t\tif (self.extraFeatures.questionMarkCheck) {\n\t\t\t\t\tcontext._questionMarkCheck(response);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trun(handler, sequenceIndex + 1, response.sessionAttributes);\n\t\t\t})\n\t\t\t.catch(done);\n\t}\n};\nrun(index.handler, 0, {});",
                  "err": {},
                  "uuid": "280edf1e-64cb-49c9-a870-7f168ff192c6",
                  "parentUUID": "70e7e4a5-3354-46ce-95f0-f7cbeb421447",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "280edf1e-64cb-49c9-a870-7f168ff192c6"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 2000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    }
  ],
  "meta": {
    "mocha": {
      "version": "9.1.3"
    },
    "mochawesome": {
      "options": {
        "quiet": false,
        "reportFilename": "mochawesome",
        "saveHtml": true,
        "saveJson": true,
        "consoleReporter": "spec",
        "useInlineDiffs": false,
        "code": true
      },
      "version": "7.0.1"
    },
    "marge": {
      "options": null,
      "version": "6.0.1"
    }
  }
}
